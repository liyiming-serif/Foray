<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>self</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Init(dir, is_friendly, model_name)

direction = arg_buff[0];
is_friendly = arg_buff[1];
key = arg_buff[2];
mp = ds_map_find_value(global.models, key);

chassis = ds_map_find_value(mp, "chassis");

//orient the plane
image_angle = direction;

//params common to every model
max_hp = ds_map_find_value(global.PLANES,"max_hp");
turn_speed = ds_map_find_value(global.PLANES,"turn_speed");

var cmp;
cmp = ds_map_find_value(global.PLANES,"c_hull");
scr_c_hull_add(cmp);
scr_c_plane_engine_add();

//variable fields
has_pilot = true;

//animation
anim_state = plane_anim_states.NORM;
scr_plane_get_sprite();
turn_state = plane_turn_states.NEUTRAL;
scr_plane_set_sprite();
//hardcoded values
roll_start_frame = 5;
roll_end_frame = 11;

//palette swap shader
scr_c_palette_add();
//flash shader
flash_color_ref = shader_get_uniform(shader_flash, "flashColor");

//stealing mechanic flags
is_stealable = false;
if(global.AB_USE_CHARGE_STEAL){
    locking_on = false;
    steal_progress = 0;
}

if(global.AB_USE_ANGLE_STEAL){
    starting_angle = 0; //mid-point of angles
    angles = -1;
}
ready_to_steal = false;

//steal ui shaders
if(global.AB_USE_CHARGE_STEAL){
    steal_angles_ref = shader_get_uniform(shader_radial_bar, "angles");
    steal_origin_ref = shader_get_uniform(shader_radial_bar, "origin");
    steal_uvs_ref = shader_get_uniform(shader_radial_bar, "spriteUVs");
}
else if(global.AB_USE_ANGLE_STEAL){
    steal_angles_ref = shader_get_uniform(shader_angle, "angles");
    steal_origin_ref = shader_get_uniform(shader_angle, "origin");
    steal_uvs_ref = shader_get_uniform(shader_angle, "spriteUVs");
}

//particle counters
smoke_counter = global.SMOKE_RATE;
trail_counter = global.TRAIL_RATE;

//GUI: stealing reticle, sweep, and arrow
reticle_img_ind = 0;
reticle_scale = 1;
if(global.AB_USE_CHARGE_STEAL){
    reticle_on_img_ind = 0;
    reticle_aim_img_ind = 0;
    reticle_dot_img_ind = 0;
}
if(global.AB_USE_ANGLE_STEAL){
    sweep_img_ind = 0;
    arrow_img_ind = 0;
}

//arm the plane
wpn_ind = asset_get_index(ds_map_find_value(mp,"wpn_ind"));
gid = scr_wpn_equip(x,y,wpn_ind,direction,is_friendly);

//These stats represent how many stars the player sees.
//Use the global lookup table to interpolate the in-game values these
//stats represent.
display_name = ds_map_find_value(mp,"name");
display_speed = round(clamp(speed_rank,1,global.MAX_STATS));
display_turn = round(clamp(turn_rank,1,global.MAX_STATS));
display_wpn = gid.name;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///garbage collection

scr_play_sound(snd_explosion_m,x,y);

//clean up all sounds under emitter
audio_stop_sound(engine_sound);
if(variable_instance_exists(id,"crashing_sound")){
    audio_stop_sound(crashing_sound);
}

//dispose function for all ships
scr_ship_gc();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///AI: poll for target
if(!is_friendly){
    target_id = global.player_id;
    alarm[update_target_time_alarm] = update_target_time;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///end turn state change
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Turn off plane shooting sprite

scr_c_palette_flash_off();

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Update weapon
scr_ship_update_wpn(sprite_width-sprite_xoffset-2,image_angle,gid);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Advance frame

scr_plane_step();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_solid_parent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///enable solid collisions
scr_c_hull_collide_with_obstacle();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_projectile_parent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Generic hit script

if(roll_invuln == 0){
    scr_c_hull_collide_with_projectile();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_skymine">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Custom hit script

if(roll_invuln == 0){
    scr_c_hull_collide_with_skymine();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="7">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///stop rolling

if(is_rolling &amp;&amp; roll_invuln==0){
    anim_state = plane_anim_states.NORM;
    scr_plane_get_sprite();
    is_rolling = false;
    roll_cool = roll_cooldown;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///clean up abandoned planes
if(!has_pilot &amp;&amp; instance_number(obj_player_avatar)&lt;1){
    instance_destroy();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw steal UI

scr_ship_draw_ui();

if(!is_stealable || hp&lt;=0){
    return undefined;
}

reticle_scale = max(lerp(reticle_scale, 0.9, 0.2), 1);

if(global.AB_USE_CHARGE_STEAL){
    var ret_spr, ret_spr_aim, ret_spr_dot, ret_spr_on, d_pos;
    ret_spr = spr_steal_reticle_off;
    ret_spr_aim = spr_steal_reticle_aim;
    ret_spr_dot = spr_steal_reticle_dot;
    ret_spr_on = spr_steal_reticle_oy;
    d_pos = scr_game_to_gui(x,y);
    
    //State: not stealing
    if(!mouse_check_button(mb_right)){
        //small reticle
        draw_sprite_ext(ret_spr, reticle_img_ind,
            d_pos[0], d_pos[1], reticle_scale, reticle_scale,
            0,c_white,1);
        reticle_img_ind = (reticle_img_ind+global.STEAL_RETICLE_ANIM_SPEED)%
            sprite_get_number(ret_spr);
    }
    //State: in steal mode, but not aiming at this plane
    else if(!locking_on){
        draw_sprite_ext(ret_spr, reticle_img_ind,
            d_pos[0], d_pos[1], reticle_scale, reticle_scale,
            0,c_white,1);
        reticle_img_ind = (reticle_img_ind+global.STEAL_RETICLE_ANIM_SPEED)%
            sprite_get_number(ret_spr);
    }
    //State: Aiming...
    else if(steal_progress &lt; 1){
        //show steal progress by zooming in aim ret until it overlaps
        //dotted circle
        draw_sprite(ret_spr_dot, reticle_dot_img_ind, d_pos[0], d_pos[1]);
        reticle_dot_img_ind = (reticle_dot_img_ind+global.STEAL_RETICLE_DOT_ANIM_SPEED)%
            sprite_get_number(ret_spr_dot);
            
        var rs = (1-steal_progress) + 1;
        draw_sprite_ext(ret_spr_aim, reticle_aim_img_ind,
            d_pos[0], d_pos[1], rs, rs,
            0,c_white,1);
        reticle_aim_img_ind = (reticle_aim_img_ind+global.STEAL_RETICLE_AIM_ANIM_SPEED)%
            sprite_get_number(ret_spr_aim);
    }
    //State: ready to steal
    else if(ready_to_steal){
        draw_sprite(ret_spr_on, reticle_on_img_ind, d_pos[0], d_pos[1]);
        reticle_on_img_ind = (reticle_on_img_ind+global.STEAL_RETICLE_ON_ANIM_SPEED)%
            sprite_get_number(ret_spr_on);
    }
}
if(global.AB_USE_ANGLE_STEAL){
    var ret_spr, sweep_spr, arrow_spr, d_pos;
    d_pos = scr_game_to_gui(x,y);
    
    if(!mouse_check_button(mb_right)){ //steal-mode not on = small reticle
        //Draw reticle sweep small
        sweep_spr = spr_steal_sweep_sm;
        
        shader_set(shader_angle);
        var sweep_ang = scr_plane_ui_get_angles(starting_angle, 
            degtorad(angle_difference(image_angle,0)));
        shader_set_uniform_f_array(steal_angles_ref, sweep_ang);
        var originx = sprite_get_xoffset(sweep_spr)/sprite_get_width(sweep_spr);
        var originy = sprite_get_yoffset(sweep_spr)/sprite_get_height(sweep_spr);
        shader_set_uniform_f(steal_origin_ref, originx, originy);
        var uvs = sprite_get_uvs(sweep_spr,sweep_img_ind);
        shader_set_uniform_f(steal_uvs_ref,uvs[0],uvs[3],1/(uvs[2]-uvs[0]),1/(uvs[1]-uvs[3]));
        draw_sprite(sweep_spr, sweep_img_ind, d_pos[0], d_pos[1]);
        shader_reset();
        
        sweep_img_ind = (sweep_img_ind+global.STEAL_SWEEP_ANIM_SPEED)%
            sprite_get_number(sweep_spr);
            
        //Draw reticle off at 1/2 scale
        ret_spr = spr_steal_reticle_off;
        draw_sprite_ext(ret_spr, reticle_img_ind,
            d_pos[0], d_pos[1], 0.5, 0.5,
            0,c_white,1);
        reticle_img_ind = (reticle_img_ind+global.STEAL_RETICLE_ANIM_SPEED)%
            sprite_get_number(ret_spr);
        
        //Draw arrow w/ closer origin
        arrow_spr = spr_steal_arrow;
        sprite_set_offset(arrow_spr, -26, sprite_get_yoffset(arrow_spr));
        draw_sprite_ext(arrow_spr,arrow_img_ind,
            d_pos[0],d_pos[1],1,1,
            radtodeg(starting_angle)+image_angle,c_white,1);
        arrow_img_ind = (arrow_img_ind+global.STEAL_ARROW_ANIM_SPEED)%
            sprite_get_number(arrow_spr);
    }
    else if(ready_to_steal){
        //Draw reticle sweep
        sweep_spr = spr_steal_sweep_on;

        shader_set(shader_angle);
        var sweep_ang = scr_plane_ui_get_angles(starting_angle, 
            degtorad(angle_difference(image_angle,0)));
        shader_set_uniform_f_array(steal_angles_ref, sweep_ang);
        var originx = sprite_get_xoffset(sweep_spr)/sprite_get_width(sweep_spr);
        var originy = sprite_get_yoffset(sweep_spr)/sprite_get_height(sweep_spr);
        shader_set_uniform_f(steal_origin_ref, originx, originy);
        var uvs = sprite_get_uvs(sweep_spr,sweep_img_ind);
        shader_set_uniform_f(steal_uvs_ref,uvs[0],uvs[3],1/(uvs[2]-uvs[0]),1/(uvs[1]-uvs[3]));
        draw_sprite(sweep_spr, sweep_img_ind, d_pos[0], d_pos[1]);
        shader_reset();
        
        sweep_img_ind = (sweep_img_ind+global.STEAL_SWEEP_ON_ANIM_SPEED)%
            sprite_get_number(sweep_spr);
            
        //Draw reticle active
        ret_spr = spr_steal_reticle_on;
        draw_sprite(ret_spr, reticle_img_ind, d_pos[0], d_pos[1]);
        reticle_img_ind = (reticle_img_ind+global.STEAL_RETICLE_ON_ANIM_SPEED)%
            sprite_get_number(ret_spr);
    }
    else{
        //Draw reticle sweep
        sweep_spr = spr_steal_sweep;
        
        shader_set(shader_angle);
        var sweep_ang = scr_plane_ui_get_angles(starting_angle, 
            degtorad(angle_difference(image_angle,0)));
        shader_set_uniform_f_array(steal_angles_ref, sweep_ang);
        var originx = sprite_get_xoffset(sweep_spr)/sprite_get_width(sweep_spr);
        var originy = sprite_get_yoffset(sweep_spr)/sprite_get_height(sweep_spr);
        shader_set_uniform_f(steal_origin_ref, originx, originy);
        var uvs = sprite_get_uvs(sweep_spr,sweep_img_ind);
        shader_set_uniform_f(steal_uvs_ref,uvs[0],uvs[3],1/(uvs[2]-uvs[0]),1/(uvs[1]-uvs[3]));
        draw_sprite(sweep_spr, sweep_img_ind, d_pos[0], d_pos[1]);
        shader_reset();
        
        sweep_img_ind = (sweep_img_ind+global.STEAL_SWEEP_ANIM_SPEED)%
            sprite_get_number(sweep_spr);
    
        //Draw reticle off
        ret_spr = spr_steal_reticle_off;
        draw_sprite(ret_spr, reticle_img_ind, d_pos[0], d_pos[1]);
        reticle_img_ind = (reticle_img_ind+global.STEAL_RETICLE_ANIM_SPEED)%
            sprite_get_number(ret_spr);
        
        //Draw steal arrow
        arrow_spr = spr_steal_arrow;
        sprite_set_offset(arrow_spr, -52, sprite_get_yoffset(arrow_spr));
        draw_sprite_ext(arrow_spr,arrow_img_ind,
            d_pos[0],d_pos[1],1,1,
            radtodeg(starting_angle)+image_angle,c_white,1);
        arrow_img_ind = (arrow_img_ind+global.STEAL_ARROW_ANIM_SPEED)%
            sprite_get_number(arrow_spr);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///scr_plane_shade

if(sprite_index == -1){
    exit;
}

//cast shadow
scr_cast_shadow();

//Decide which shader to use for this frame. CALL ONLY DURING DRAW EVENT
if (is_stealable &amp;&amp; image_index%3&gt;1.5){ //apply red/warn flash
    if(global.AB_USE_CHARGE_STEAL &amp;&amp; locking_on){
        shader_set(shader_flash);
        shader_set_uniform_f_array(flash_color_ref, global.C_FLASH_WARN_NORM);
    }
    else{
        shader_set(shader_hurt_flash);
    }
}
else if (hitstun&gt;0){ //apply white flash
    shader_set(shader_hit_flash);
}
else{ //apply palette swap shader
    scr_c_palette_set_shade();
}
draw_self();
shader_reset();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
